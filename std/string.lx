//! String manipulation and conversion utilities
//!
//! This module provides functions for working with null-terminated C-style strings,
//! including concatenation, comparison, conversion, and character classification.
//! All strings are represented as pointers to byte arrays (`*byte`) and must be
//! null-terminated.
//!
//! # Memory Management
//! Functions that create new strings (prefixed with `from_` or returning `#returns_ownership`)
//! allocate memory that the caller must free. Use `defer { free(str); }` to ensure cleanup.

@module "string"

/// Forward declarations for functions used within this module
pub const cat -> fn (dest: *byte, s1: *byte, s2: *byte) *byte;
pub const strlen -> fn (s: *byte) int;

/// Returns the length of a null-terminated string
///
/// Counts characters until the null terminator is found.
///
/// # Parameters
/// * `s` - String to measure
///
/// # Returns
/// Number of characters before null terminator
///
/// # Example
/// ```luma
/// let len: int = string::strlen("Hello");
/// // len will be 5
/// ```
//
pub const Slice -> struct {
    ptr: *byte, len: int,

    slice_end -> fn () *byte { return cast<*byte>(cast<int>(self.ptr) + self.len); },

    null_terminated_slice -> fn (s: *byte) Slice {
        let len: int = 0;
        let cursor: *byte = s;

        loop (cursor != cast<*byte>(0) && *cursor != '\0')
            : (cursor = cast<*byte>(cast<int>(cursor) + 1)) {
            len++;
        }

        return Slice { ptr: s, len: len };
    }
};

//
pub const String -> struct {
    slice: Slice, cap: int,

    #returns_ownership
    concat_strs -> fn (start: *Slice, len: int) String {
        let end: *Slice = cast<*Slice>(cast<int>(start) + len * sizeof<Slice>);
        let total_len: int = 0;

        loop [cursor: *Slice = start](cursor != end)
            : (cursor = cast<*Slice>(cast<int>(cursor) + sizeof<Slice>)) {
            total_len = total_len + cursor.len;
        }

        let ptr: *byte = cast<*byte>(alloc(total_len + 1));
        let out_cursor: *byte = ptr;

        loop [cursor: *Slice = start](cursor != end)
            : (cursor = cast<*Slice>(cast<int>(cursor) + sizeof<Slice>)) {

            let slice_end: *byte = cursor.slice_end();

            loop [slice_cursor: *byte = cursor.ptr](slice_cursor != slice_end)
                : (slice_cursor = cast<*byte>(cast<int>(slice_cursor) + 1)) {
                *out_cursor = *slice_cursor;
                out_cursor = cast<*byte>(cast<int>(out_cursor) + 1);
            }
        }
        *out_cursor = '\0';

        return String { slice: Slice { ptr: ptr, len: total_len }, cap: total_len };
    },

    as_slice -> fn () Slice { return self.slice; }
};

#takes_ownership
pub const free_string -> fn (s: *String) void {
    free(s.slice.ptr);
}

/// Converts a single byte to a string
///
/// Creates a 2-byte string containing the character and a null terminator.
///
/// # Parameters
/// * `c` - Character to convert
///
/// # Returns
/// Newly allocated string containing the character
///
/// # Example
/// ```luma
/// let str: *byte = string::from_byte('A');
/// defer { free(str); }
/// output(str); // Prints "A"
/// ```
#returns_ownership 
pub const from_byte -> fn (c: byte) *byte {
  let s: *byte = cast<*byte>(alloc(2 * sizeof<byte>));
  s[0] = c;
  s[1] = cast<byte>(0);
  return s;
}

/// Converts an integer to a string
///
/// Handles both positive and negative integers. For zero, returns "0".
///
/// # Parameters
/// * `n` - Integer to convert
///
/// # Returns
/// Newly allocated string representation of the integer
///
/// # Example
/// ```luma
/// let str: *byte = string::from_int(-42);
/// defer { free(str); }
/// output(str); // Prints "-42"
/// ```
#returns_ownership
pub const from_int -> fn (n: int) *byte {
  if (n == 0) {
    return from_byte(cast<byte>('0'));
  }

  let negative: int = 0;
  if (n < 0) {
    negative = 1;
    n = -n;
  }

  let buffer: [byte; 20]; // enough for 64-bit int
  let i: int = 0;

  loop (n != 0) {
    let digit: int = n % 10;
    buffer[i] = cast<byte>(digit + cast<int>('0'));
    n = n / 10;
    i = i + 1;
  }

  if (negative == 1) {
    buffer[i] = '-';
    i = i + 1;
  }

  // Reverse the string
  let s: *byte = cast<*byte>(alloc((i + 1) * sizeof<byte>));
  loop [j: int = 0](j < i) : (j = j + 1) {
    s[j] = buffer[i - j - 1];
  }
  s[i] = cast<byte>(0); // null terminator

  return s;
}

/// Converts a float to a string with specified precision
///
/// Separates integer and fractional parts, then combines them with
/// a decimal point. Precision determines number of decimal places.
///
/// # Parameters
/// * `f` - Float value to convert
/// * `precision` - Number of decimal places to include
///
/// # Returns
/// Newly allocated string representation of the float
///
/// # Example
/// ```luma
/// let str: *byte = string::from_float(3.14159, 2);
/// defer { free(str); }
/// output(str); // Prints "3.14"
/// ```
#returns_ownership
pub const from_float -> fn (f: float, precision: int) *byte {
  let int_part: int = cast<int>(f);
  let frac_part: float = f - cast<float>(int_part);
  
  let int_str: *byte = from_int(int_part);
  defer { free(int_str); }
  
  let frac_str: *byte = cast<*byte>(alloc((precision + 2) * sizeof<byte>)); // +1 for '.' +1 for null
  frac_str[0] = '.';
  
  loop [i: int = 1](i <= precision) : (++i) {
    frac_part = frac_part * 10.0;
    let digit: int = cast<int>(frac_part);
    frac_str[i] = cast<byte>(digit + cast<int>('0'));
    frac_part = frac_part - cast<float>(digit);
  }
  
  frac_str[precision + 1] = cast<byte>(0); // null terminator
  
  let result_len: int = strlen(int_str) + strlen(frac_str) + 1;
  let result: *byte = cast<*byte>(alloc(result_len * sizeof<byte>));
  
  cat(result, int_str, frac_str);
  
  return result;
}

/// Converts integer to string into a provided buffer
///
/// Writes the string representation directly into the provided buffer
/// instead of allocating new memory.
///
/// # Parameters
/// * `num` - Integer to convert
/// * `buf` - Buffer to write string into
/// * `buf_size` - Size of buffer in bytes
///
/// # Example
/// ```luma
/// let buffer: [byte; 32];
/// string::int_to_str(12345, &buffer[0], 32);
/// output(&buffer[0]); // Prints "12345"
/// ```
pub const int_to_str -> fn (num: int, buf: *byte, buf_size: int) void {
  let idx: int = 0;
  let temp: int = num;
  
  if (temp == 0) {
    buf[0] = '0';
    buf[1] = '\0';
    return;
  }
  
  loop (temp > 0 && idx < buf_size - 1) {
    buf[idx] = cast<byte>((temp % 10) + 48);
    temp = temp / 10;
    idx = idx + 1;
  }
  
  // Reverse the digits
  let j: int = 0;
  loop (j < idx / 2) {
    let tmp: byte = buf[j];
    buf[j] = buf[idx - 1 - j];
    buf[idx - 1 - j] = tmp;
    j = j + 1;
  }
  
  buf[idx] = '\0';
}

pub const strlen -> fn (s: *byte) int {
  let length: int = 0;
  loop (s[length] != cast<byte>(0)) : (++length) {}
  return length;
}

/// Compares two strings for equality
///
/// First checks if lengths differ, then compares contents byte by byte.
///
/// # Parameters
/// * `s1` - First string
/// * `s2` - Second string
///
/// # Returns
/// * `0` if strings are equal
/// * `-1` if lengths differ
/// * `1` if contents differ but lengths match
///
/// # Example
/// ```luma
/// if (string::strcmp("hello", "hello") == 0) {
///     output("Strings are equal\n");
/// }
/// ```
pub const strcmp -> fn (s1: *byte, s2: *byte) int {
  let ls1: int = strlen(s1);
  let ls2: int = strlen(s2);

  if (ls1 != ls2) { return -1; }

  loop[i: int = 0](i < ls1) : (++i) {
    if (s1[i] != s2[i]) { return 1; }
  }

  return 0;
}

/// Searches for a character in a string
///
/// Returns the first occurrence of the character, or null byte if not found.
///
/// # Parameters
/// * `s` - String to search
/// * `c` - Character to find (as int)
///
/// # Returns
/// The matching character if found, null byte otherwise
///
/// # Example
/// ```luma
/// let ch: byte = string::s_byte("Hello", cast<int>('l'));
/// if (ch != cast<byte>(0)) {
///     output("Found 'l'\n");
/// }
/// ```
pub const s_byte -> fn (s: *byte, c: int) byte{
  loop [i: int = 0](s[i] != cast<byte>(0)) : (++i) {
    if (s[i] == cast<byte>(c)) {
      return s[i];
    }
  }

  return cast<byte>(0);
}

/// Copies a string from source to destination
///
/// Copies characters including the null terminator.
///
/// # Parameters
/// * `dest` - Destination buffer (must be large enough)
/// * `src` - Source string
///
/// # Returns
/// Destination pointer
///
/// # Example
/// ```luma
/// let buffer: [byte; 100];
/// string::copy(&buffer[0], "Hello");
/// ```
pub const copy -> fn (dest: *byte, src: *byte) *byte {
  let i: int = 0;
  loop((dest[i] = src[i]) != cast<byte>(0)) : (++i) {}
  return dest;
}

/// Copies at most n bytes of a string
///
/// Stops at null terminator or after n characters, whichever comes first.
///
/// # Parameters
/// * `dest` - Destination buffer
/// * `src` - Source string
/// * `n` - Maximum bytes to copy
///
/// # Returns
/// Destination pointer
///
/// # Example
/// ```luma
/// let buffer: [byte; 10];
/// string::n_copy(&buffer[0], "Hello World", 5); // Copies "Hello"
/// ```
pub const n_copy -> fn (dest: *byte, src: *byte, n: int) *byte {
  let i: int = 0;
  loop(i < n && src[i] != cast<byte>(0)) : (++i) {
    dest[i] = src[i]; 
  }
  return dest;
}

/// Concatenates two strings into a destination buffer
///
/// Writes s1 followed by s2 into dest, with null terminator.
///
/// # Parameters
/// * `dest` - Destination buffer (must be large enough)
/// * `s1` - First string
/// * `s2` - Second string
///
/// # Returns
/// Destination pointer
///
/// # Example
/// ```luma
/// let buffer: [byte; 100];
/// string::cat(&buffer[0], "Hello ", "World");
/// output(&buffer[0]); // Prints "Hello World"
/// ```
pub const cat -> fn (dest: *byte, s1: *byte, s2: *byte) *byte {
  let ls1: int = strlen(s1);
  let lt: int = ls1 + strlen(s2) + 1;

  loop [i: int = 0](i < lt) : (++i) {
    if (i < ls1) {
      dest[i] = s1[i];
    } else {
      dest[i] = s2[i - ls1];
    }
  }

  // null terminator
  dest[lt - 1] = cast<byte>(0);

  return dest;
}

/// Outputs a single character to the terminal
///
/// Handles special characters with proper shell escaping using system commands.
/// Special handling for newline, tab, quotes, backslash, etc.
///
/// # Parameters
/// * `c` - Character to output
///
/// # Returns
/// The character as an int
///
/// # Example
/// ```luma
/// string::putbyte('A');
/// string::putbyte('\n');
/// ```
pub const putbyte -> fn(c: byte) int {
  // allocate buffer for command + escaped byte (32 bytes is enough)
  let cmd: *byte = cast<*byte>(alloc(32 * sizeof<byte>));
  defer { free(cmd); }

  // build command inline
  // Use integer values instead of character literals with escapes
  let byte_val: int = cast<int>(c);
  
  switch(byte_val) {
      10 -> { system("echo"); }                                        // '\n'
      9  -> { system("printf '\\t'"); }                                // '\t'
      37 -> cat(cmd, cast<*byte>("printf '\\%'"),  cast<*byte>(""));   // '%'
      92 -> cat(cmd, cast<*byte>("printf '\\\\'"), cast<*byte>(""));   // '\\'
      39 -> cat(cmd, cast<*byte>("printf '\\\''"), cast<*byte>(""));   // '\''
      34 -> cat(cmd, cast<*byte>("printf '\\'"), cast<*byte>(""));     // '"'
      36 -> cat(cmd, cast<*byte>("printf '\\$'"),  cast<*byte>(""));   // '$'
      96 -> cat(cmd, cast<*byte>("printf '\\`'"),  cast<*byte>(""));   // '`'
      _  -> {
          let s: *byte = from_byte(c);
          defer { free(s); }
          cat(cmd, cast<*byte>("printf '%s' "), s);
      }
  }

  if (byte_val != 10 && byte_val != 9) { system(cmd); }
  
  return cast<int>(c);
}

/// Checks if a character is a digit (0-9)
///
/// # Parameters
/// * `ch` - Character to test
///
/// # Returns
/// true if character is '0' through '9', false otherwise
///
/// # Example
/// ```luma
/// if (string::is_digit('5')) {
///     output("It's a digit!\n");
/// }
/// ```
pub const is_digit -> fn (ch: byte) bool {
  return (ch >= '0' && ch <= '9');
}

/// Checks if a character is alphabetic or underscore
///
/// Accepts uppercase letters (A-Z), lowercase letters (a-z),
/// underscore (_), and at sign (@).
///
/// # Parameters
/// * `ch` - Character to test
///
/// # Returns
/// true if alphabetic or underscore/at, false otherwise
///
/// # Example
/// ```luma
/// if (string::is_alpha('_')) {
///     output("Valid identifier character\n");
/// }
/// ```
pub const is_alpha -> fn (ch: byte) bool {
  return ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_' || ch == '@');
}

/// Checks if a character is alphanumeric
///
/// Returns true if character is a letter, digit, underscore, or at sign.
///
/// # Parameters
/// * `ch` - Character to test
///
/// # Returns
/// true if alphanumeric, false otherwise
///
/// # Example
/// ```luma
/// if (string::is_alnum('A')) {
///     output("Valid identifier character\n");
/// }
/// ```
pub const is_alnum -> fn (ch: byte) bool {
  return (is_alpha(ch) || is_digit(ch));
}

/// Converts ASCII string to integer
///
/// Parses digits from the string until a non-digit character is encountered.
/// Does not handle negative numbers or leading whitespace.
///
/// # Parameters
/// * `value` - String to parse
///
/// # Returns
/// Parsed integer value
///
/// # Example
/// ```luma
/// let num: int = string::atio("12345");
/// // num will be 12345
/// ```
pub const atio -> fn (value: *byte) int {
  let num: int = 0;
  loop [i: int = 0](value[i] != '\0') : (++i) { 
    if (cast<int>(value[i]) >= 48 && cast<int>(value[i]) <= 57) { 
      num = num * 10 + (cast<int>(value[i]) - 48); 
    } else { 
      break; 
    }
  }
  return num;
}

/// Adds two large integers represented as strings
///
/// Performs arbitrary-precision addition digit by digit with carry propagation.
/// Both input strings must contain only digits.
///
/// # Parameters
/// * `num1` - First number as string
/// * `num2` - Second number as string
///
/// # Returns
/// Sum as newly allocated string
///
/// # Example
/// ```luma
/// let result: *byte = string::string_add("999", "1");
/// defer { free(result); }
/// output(result); // Prints "1000"
/// ```
#returns_ownership
pub const string_add -> fn (num1: *byte, num2: *byte) *byte {
  let len1: int = strlen(num1);
  let len2: int = strlen(num2);
  let max_len: int = 0;
  if (len1 > len2) max_len = len1; else max_len = len2;
  
  // Result can be at most max_len + 1 digits
  let result: *byte = cast<*byte>(alloc(max_len + 2));
  let carry: int = 0;
  let result_idx: int = 0;
  
  let i1: int = len1 - 1;
  let i2: int = len2 - 1;
  
  // Add digits from right to left
  loop (i1 >= 0 || i2 >= 0 || carry > 0) {
    let digit1: int = 0;
    let digit2: int = 0;

    if (i1 >= 0) digit1 = (cast<int>(num1[i1]) - 48); else digit1 = 0;
    if (i2 >= 0) digit2 = (cast<int>(num2[i2]) - 48); else digit2 = 0;

    
    let sum: int = digit1 + digit2 + carry;
    carry = sum / 10;
    result[result_idx++] = cast<byte>((sum % 10) + 48);
    
    i1--;
    i2--;
  }
  
  // Reverse the result
  loop [i: int = 0](i < result_idx / 2) : (++i) {
    let temp: byte = result[i];
    result[i] = result[result_idx - 1 - i];
    result[result_idx - 1 - i] = temp;
  }
  
  result[result_idx] = '\0';
  return result;
}

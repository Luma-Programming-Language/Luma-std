@module "string"

pub const cat -> fn (dest: *byte, s1: *byte, s2: *byte) *byte;
pub const strlen -> fn (s: *byte) int;

#returns_ownership 
pub const from_byte -> fn (c: byte) *byte {
  let s: *byte = cast<*byte>(alloc(2 * sizeof<byte>));
  s[0] = c;
  s[1] = cast<byte>(0);
  return s;
}

#returns_ownership
pub const from_int -> fn (n: int) *byte {
  if (n == 0) {
    return from_byte(cast<byte>('0'));
  }

  let negative: int = 0;
  if (n < 0) {
    negative = 1;
    n = -n;
  }

  let buffer: [byte; 20]; // enough for 64-bit int
  let i: int = 0;

  loop (n != 0) {
    let digit: int = n % 10;
    buffer[i] = cast<byte>(digit + cast<int>('0'));
    n = n / 10;
    i = i + 1;
  }

  if (negative == 1) {
    buffer[i] = '-';
    i = i + 1;
  }

  // Reverse the string
  let s: *byte = cast<*byte>(alloc((i + 1) * sizeof<byte>));
  loop [j: int = 0](j < i) : (j = j + 1) {
    s[j] = buffer[i - j - 1];
  }
  s[i] = cast<byte>(0); // null terminator

  return s;
}

#returns_ownership
pub const from_float -> fn (f: float, precision: int) *byte {
  let int_part: int = cast<int>(f);
  let frac_part: float = f - cast<float>(int_part);
  
  let int_str: *byte = from_int(int_part);
  defer { free(int_str); }
  
  let frac_str: *byte = cast<*byte>(alloc((precision + 2) * sizeof<byte>)); // +1 for '.' +1 for null
  frac_str[0] = '.';
  
  loop [i: int = 1](i <= precision) : (++i) {
    frac_part = frac_part * 10.0;
    let digit: int = cast<int>(frac_part);
    frac_str[i] = cast<byte>(digit + cast<int>('0'));
    frac_part = frac_part - cast<float>(digit);
  }
  
  frac_str[precision + 1] = cast<byte>(0); // null terminator
  
  let result_len: int = strlen(int_str) + strlen(frac_str) + 1;
  let result: *byte = cast<*byte>(alloc(result_len * sizeof<byte>));
  
  cat(result, int_str, frac_str);
  
  return result;
}

pub const int_to_str -> fn (num: int, buf: *byte, buf_size: int) void {
  let idx: int = 0;
  let temp: int = num;
  
  if (temp == 0) {
    buf[0] = '0';
    buf[1] = '\0';
    return;
  }
  
  loop (temp > 0 && idx < buf_size - 1) {
    buf[idx] = cast<byte>((temp % 10) + 48);
    temp = temp / 10;
    idx = idx + 1;
  }
  
  // Reverse the digits
  let j: int = 0;
  loop (j < idx / 2) {
    let tmp: byte = buf[j];
    buf[j] = buf[idx - 1 - j];
    buf[idx - 1 - j] = tmp;
    j = j + 1;
  }
  
  buf[idx] = '\0';
}

pub const strlen -> fn (s: *byte) int {
  let length: int = 0;
  loop (s[length] != cast<byte>(0)) : (++length) {}
  return length;
}

pub const strcmp -> fn (s1: *byte, s2: *byte) int {
  let ls1: int = strlen(s1);
  let ls2: int = strlen(s2);

  if (ls1 != ls2) { return -1; }

  loop[i: int = 0](i < ls1) : (++i) {
    if (s1[i] != s2[i]) { return 1; }
  }

  return 0;
}

pub const s_byte -> fn (s: *byte, c: int) byte{
  loop [i: int = 0](s[i] != cast<byte>(0)) : (++i) {
    if (s[i] == cast<byte>(c)) {
      return s[i];
    }
  }

  return cast<byte>(0);
}

pub const copy -> fn (dest: *byte, src: *byte) *byte {
  let i: int = 0;
  loop((dest[i] = src[i]) != cast<byte>(0)) : (++i) {}
  return dest;
}

pub const n_copy -> fn (dest: *byte, src: *byte, n: int) *byte {
  let i: int = 0;
  loop(i < n && src[i] != cast<byte>(0)) : (++i) {
    dest[i] = src[i]; 
  }
  return dest;
}

pub const cat -> fn (dest: *byte, s1: *byte, s2: *byte) *byte {
  let ls1: int = strlen(s1);
  let lt: int = ls1 + strlen(s2) + 1;

  loop [i: int = 0](i < lt) : (++i) {
    if (i < ls1) {
      dest[i] = s1[i];
    } else {
      dest[i] = s2[i - ls1];
    }
  }

  // null terminator
  dest[lt - 1] = cast<byte>(0);

  return dest;
}

pub const putbyte -> fn(c: byte) int {
  // allocate buffer for command + escaped byte (32 bytes is enough)
  let cmd: *byte = cast<*byte>(alloc(32 * sizeof<byte>));
  defer { free(cmd); }

  // build command inline
  // Use integer values instead of byteacter literals with escapes
  let byte_val: int = cast<int>(c);
  
  switch(byte_val) {
      10 -> { system("echo"); }                                        // '\n'
      9  -> { system("printf '\\t'"); }                                // '\t'
      37 -> cat(cmd, cast<*byte>("printf '\\%'"),  cast<*byte>(""));   // '%'
      92 -> cat(cmd, cast<*byte>("printf '\\\\'"), cast<*byte>(""));   // '\\'
      39 -> cat(cmd, cast<*byte>("printf '\\\''"), cast<*byte>(""));   // '\''
      34 -> cat(cmd, cast<*byte>("printf '\\'"), cast<*byte>(""));     // '"'
      36 -> cat(cmd, cast<*byte>("printf '\\$'"),  cast<*byte>(""));   // '$'
      96 -> cat(cmd, cast<*byte>("printf '\\`'"),  cast<*byte>(""));   // '`'
      _  -> {
          let s: *byte = from_byte(c);
          defer { free(s); }
          cat(cmd, cast<*byte>("printf '%s' "), s);
      }
  }

  if (byte_val != 10 && byte_val != 9) { system(cmd); }
  
  return cast<int>(c);
}

pub const is_digit -> fn (ch: byte) bool {
  return (ch >= '0' && ch <= '9');
}

pub const is_alpha -> fn (ch: byte) bool {
  return ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_' || ch == '@');
}

pub const is_alnum -> fn (ch: byte) bool {
  return (is_alpha(ch) || is_digit(ch));
}

pub const atio -> fn (value: *byte) int {
  let num: int = 0;
  loop [i: int = 0](value[i] != '\0') : (++i) { 
    if (cast<int>(value[i]) >= 48 && cast<int>(value[i]) <= 57) { 
      num = num * 10 + (cast<int>(value[i]) - 48); 
    } else { 
      break; 
    }
  }
  return num;
}

#returns_ownership
pub const string_add -> fn (num1: *byte, num2: *byte) *byte {
  let len1: int = strlen(num1);
  let len2: int = strlen(num2);
  let max_len: int = 0;
  if (len1 > len2) max_len = len1; else max_len = len2;
  
  // Result can be at most max_len + 1 digits
  let result: *byte = cast<*byte>(alloc(max_len + 2));
  let carry: int = 0;
  let result_idx: int = 0;
  
  let i1: int = len1 - 1;
  let i2: int = len2 - 1;
  
  // Add digits from right to left
  loop (i1 >= 0 || i2 >= 0 || carry > 0) {
    let digit1: int = 0;
    let digit2: int = 0;

    if (i1 >= 0) digit1 = (cast<int>(num1[i1]) - 48); else digit1 = 0;
    if (i2 >= 0) digit2 = (cast<int>(num2[i2]) - 48); else digit2 = 0;

    
    let sum: int = digit1 + digit2 + carry;
    carry = sum / 10;
    result[result_idx++] = cast<byte>((sum % 10) + 48);
    
    i1--;
    i2--;
  }
  
  // Reverse the result
  loop [i: int = 0](i < result_idx / 2) : (++i) {
    let temp: byte = result[i];
    result[i] = result[result_idx - 1 - i];
    result[result_idx - 1 - i] = temp;
  }
  
  result[result_idx] = '\0';
  return result;
}

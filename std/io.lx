//! Input/Output operations module
//!
//! This module provides formatted printing functions and file reading capabilities.
//! It supports basic format specifiers (%d, %s, %c) for printing different types
//! and includes a dynamic buffer system for efficient file reading.

@module "io"

@use "string" as string
@use "memory" as mem
@use "sys" as sys

/// Initial buffer size for file reading operations (4KB)
const INITIAL_BUFFER_SIZE: int = 4096;  // Start with 4KB

/// Factor by which buffers grow when they need to expand
const BUFFER_GROWTH_FACTOR: int = 2;     // Double size when growing

/// Prints a formatted string with integer arguments to stdout
///
/// This function performs simple printf-style formatting, supporting only the %d
/// format specifier for integers. The format string is scanned character by character,
/// and %d sequences are replaced with the corresponding integer from the args array.
///
/// # Parameters
/// * `s` - Format string containing text and %d placeholders
/// * `args` - Array of up to 256 integers to substitute into the format string
///
/// # Returns
/// The number of bytes written to stdout, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_int -> fn (s: *byte, args: [int; 256]) int {
    // Simple implementation: only supports %d for integers
    let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
    let buf_index: int = 0; let arg_index: int = 0;
    defer { free(buffer); }
    
    loop [i: int = 0](s[i] != '\0') : (++i) {
        if (s[i] == '%' && s[i + 1] == 'd' && arg_index < 256) {
            let num_str: *byte = string::from_int(args[arg_index]);
            defer { free(num_str); }

            loop [j: int = 0](num_str[j] != '\0') : (++j) {
                buffer[buf_index] = num_str[j];
                buf_index = buf_index + 1;
            }
            arg_index = arg_index + 1;
            i = i + 1; // Skip 'd'
        } else {
            buffer[buf_index] = s[i];
            buf_index = buf_index + 1;
        }
    }
    buffer[buf_index] = '\0'; // Null-terminate

    let written: int = sys::write_str(sys::STDOUT, buffer);
    return written;
}

/// Prints a formatted string with string arguments to stdout
///
/// This function performs simple printf-style formatting, supporting only the %s
/// format specifier for strings. The format string is scanned character by character,
/// and %s sequences are replaced with the corresponding string from the args array.
///
/// # Parameters
/// * `s` - Format string containing text and %s placeholders
/// * `args` - Array of up to 256 string pointers to substitute into the format string
///
/// # Returns
/// The number of bytes written to stdout, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_str -> fn (s: *byte, args: [*byte; 256]) int {
    // Simple implementation: only supports %s for strings
    let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
    let buf_index: int = 0; let arg_index: int = 0;
    defer { free(buffer); }
    
    loop [i: int = 0](s[i] != '\0') : (++i) {
        if (s[i] == '%' && s[i + 1] == 's' && arg_index < 256) {
            let str_arg: *byte = args[arg_index];
            loop [j: int = 0](str_arg[j] != '\0') : (++j) {
                buffer[buf_index] = str_arg[j];
                buf_index = buf_index + 1;
            }
            arg_index = arg_index + 1;
            i = i + 1; // Skip 's'
        } else {
            buffer[buf_index] = s[i];
            buf_index = buf_index + 1;
        }
    }
    buffer[buf_index] = '\0'; // Null-terminate

    let written: int = sys::write_str(sys::STDOUT, buffer);
    return written;
}

/// Prints a formatted string with byte (character) arguments to stdout
///
/// This function performs simple printf-style formatting, supporting only the %c
/// format specifier for individual bytes/characters. The format string is scanned
/// character by character, and %c sequences are replaced with the corresponding
/// byte from the args array.
///
/// # Parameters
/// * `s` - Format string containing text and %c placeholders
/// * `args` - Array of up to 256 bytes to substitute into the format string
///
/// # Returns
/// The number of bytes written to stdout, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_byte -> fn (s: *byte, args: [byte; 256]) int {
    // Simple implementation: only supports %c for byteacters
    let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
    let buf_index: int = 0; let arg_index: int = 0;
    defer { free(buffer); }
    
    let i: int = 0;
    loop (s[i] != '\0') : (++i) {
        if (s[i] == '%' && s[i + 1] == 'c' && arg_index < 256) {
            buffer[buf_index] = args[arg_index];
            buf_index = buf_index + 1;
            arg_index = arg_index + 1;
            i = i + 1; // Skip 'c'
        } else {
            buffer[buf_index] = s[i];
            buf_index = buf_index + 1;
        }
    }
    buffer[buf_index] = '\0'; // Null-terminate

    let written: int = sys::write_str(sys::STDOUT, buffer);
    return written;
}

/// Prints a formatted error message with integer arguments to stderr
///
/// This function is similar to print_int but writes to stderr instead of stdout.
/// It supports only the %d format specifier for integers and is intended for
/// error reporting.
///
/// # Parameters
/// * `s` - Format string containing text and %d placeholders
/// * `args` - Array of up to 256 integers to substitute into the format string
///
/// # Returns
/// The number of bytes written to stderr, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_err -> fn (s: *byte, args: [int; 256]) int {
  // Simple implementation: only supports %d for integers
  let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
  let buf_index: int = 0; let arg_index: int = 0;
  defer { free(buffer); }
  
  loop [i: int = 0](s[i] != '\0') : (++i) {
      if (s[i] == '%' && s[i + 1] == 'd' && arg_index < 256) {
          let num_str: *byte = string::from_int(args[arg_index]);
          defer { free(num_str); }

          loop [j: int = 0](num_str[j] != '\0') : (++j) {
              buffer[buf_index] = num_str[j];
              buf_index = buf_index + 1;
          }
          arg_index = arg_index + 1;
          i = i + 1; // Skip 'd'
      } else {
          buffer[buf_index] = s[i];
          buf_index = buf_index + 1;
      }
  }
  buffer[buf_index] = '\0'; // Null-terminate

  let written: int = sys::write_str(sys::STDERR, buffer);
  return written;
}

/// Reads the entire contents of a file into a dynamically allocated buffer
///
/// This function opens a file, reads its complete contents into memory using a
/// dynamic buffer that grows as needed, and returns a pointer to the null-terminated
/// string. The buffer starts at INITIAL_BUFFER_SIZE (4KB) and doubles in size when
/// full until the entire file is read. After reading, the buffer is shrunk to the
/// exact size needed to minimize memory usage.
///
/// # Parameters
/// * `path` - Null-terminated string containing the file path to read
///
/// # Returns
/// A pointer to a newly allocated null-terminated string containing the file contents,
/// or a null pointer (0) if an error occurs. The caller is responsible for freeing
/// this memory.
///
/// # Memory
/// The returned buffer is heap-allocated and ownership is transferred to the caller.
/// The caller MUST free the returned pointer when done. Returns null on allocation
/// failures or read errors.
///
/// # Errors
/// Returns null pointer and prints error message to stderr if:
/// * File cannot be opened
/// * Memory allocation fails
/// * Read operation fails
#returns_ownership
pub const read_file -> fn (path: *byte) *byte {
  let fd: int = sys::open(path, sys::O_RDONLY, 0);
  if (sys::is_error(fd)) {
    sys::eprint("Error: Failed to open file for reading\n");
    return cast<*byte>(0);
  }

  // Start with initial buffer
  let buffer_size: int = INITIAL_BUFFER_SIZE;
  let buffer: *byte = cast<*byte>(alloc(buffer_size * sizeof<byte>));
  if (buffer == cast<*byte>(0)) {
    sys::eprint("Error: Failed to allocate initial buffer\n");
    sys::close(fd);
    return cast<*byte>(0);
  }

  let total_read: int = 0;
  let bytes_read: int = 0;

  loop {
    // Read into buffer at current position
    let read_size: int = buffer_size - total_read - 1; // Leave room for null terminator
    bytes_read = sys::read(fd, cast<*void>(cast<int>(buffer) + total_read), read_size);

    if (sys::is_error(bytes_read)) {
      sys::eprint("Error: Failed to read from file\n");
      sys::close(fd);
      free(buffer);
      return cast<*byte>(0);
    }

    // If we read 0 bytes, we've reached EOF
    if (bytes_read == 0) {
      break;
    }

    total_read = total_read + bytes_read;

    // If buffer is full (minus null terminator space), grow it
    if (total_read >= buffer_size - 1) {
      let new_size: int = buffer_size * BUFFER_GROWTH_FACTOR;
      let new_buffer: *byte = cast<*byte>(mem::realloc(cast<*void>(buffer), new_size * sizeof<byte>));
      
      if (new_buffer == cast<*byte>(0)) {
        sys::eprint("Error: Failed to grow buffer\n");
        sys::close(fd);
        free(buffer);
        return cast<*byte>(0);
      }

      buffer = new_buffer;
      buffer_size = new_size;
    }
  }

  // Null terminate the string
  buffer[total_read] = cast<byte>(0);

  // shrink buffer to exact size to save memory
  if (total_read < buffer_size - 1) {
    let final_buffer: *byte = cast<*byte>(alloc((total_read + 1) * sizeof<byte>));
    if (final_buffer != cast<*byte>(0)) {
      mem::memcpy(cast<*void>(final_buffer), cast<*void>(buffer), total_read + 1);
      free(buffer);
      buffer = final_buffer;
    }
  }

  sys::close(fd);
  return buffer;
}
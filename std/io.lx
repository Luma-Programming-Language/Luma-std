//! Input/Output operations module
//!
//! This module provides formatted printing functions and file reading capabilities.
//! It is completely self-contained with no external module dependencies.
//! All required syscalls and memory operations are implemented locally.

@module "std_io"

/// Syscall numbers (Linux x86_64)
const SYS_READ: int = 0;
const SYS_WRITE: int = 1;
const SYS_OPEN: int = 2;
const SYS_CLOSE: int = 3;

const O_RDONLY: int = 0;
const O_RDWR: int = 2;

const STDOUT: int = 1;
const STDERR: int = 2;

/// Syscall numbers (Macos x86_64) 
/// Syscall numbers (Windows x86_64)

/// Local memcpy implementation - copies n bytes from src to dest
const local_memcpy -> fn (dest: *void, src: *void, n: int) *void {
    let d: *byte = cast<*byte>(dest);
    let s: *byte = cast<*byte>(src);
    loop [i: int = 0](i < n) : (++i) {
        d[i] = s[i];
    }
    return dest;
}

/// Local realloc implementation
#returns_ownership 
const local_realloc -> fn (ptr: *void, new_size: int) *void {
    if (ptr == cast<*void>(0)) {
        return alloc(new_size);
    }
    let new_ptr: *void = alloc(new_size);
    local_memcpy(new_ptr, ptr, new_size);
    free(ptr);
    return new_ptr;
}

const local_write -> fn (fd: int, buf: *void, count: int) int {
    return __syscall__(SYS_WRITE, fd, cast<int>(buf), count);
}

const local_read -> fn (fd: int, buf: *void, count: int) int {
    return __syscall__(SYS_READ, fd, cast<int>(buf), count);
}

const local_open -> fn (path: *byte, flags: int, mode: int) int {
    return __syscall__(SYS_OPEN, cast<int>(path), flags, mode);
}

const local_close -> fn (fd: int) int {
    return __syscall__(SYS_CLOSE, fd);
}

const local_is_error -> fn (result: int) bool {
    return result < 0 && result >= -4095;
}

const local_write_str -> fn (fd: int, s: *byte) int {
    let len: int = 0;
    loop (s[len] != cast<byte>(0)) : (++len) {}
    return local_write(fd, cast<*void>(s), len);
}

const local_eprint -> fn (s: *byte) int {
    return local_write_str(STDERR, s);
}

/// Initial buffer size for file reading operations (4KB)
const INITIAL_BUFFER_SIZE: int = 4096;
/// Factor by which buffers grow when they need to expand
const BUFFER_GROWTH_FACTOR: int = 2; 

/// Type tags for format arguments
const ARG_INT: int = 0;
const ARG_STR: int = 1;
const ARG_BYTE: int = 2;
const ARG_FLOAT: int = 3;

pub const FormatArg -> struct {
  tag: int,
  str_ptr: *byte, 
  int_val: int,     
  byte_val: byte
};

pub const NULL_FORMAT_ARG: FormatArg = FormatArg {
  tag: -1,
  str_ptr: cast<*byte>(0),
  int_val: 0,
  byte_val: '\0'
};

pub const str_arg -> fn (arg: *byte) FormatArg {
  return FormatArg { 
    tag: ARG_STR,
    str_ptr: arg,
    int_val: 0,
    byte_val: '\0',
  };
}

pub const int_arg -> fn (arg: int) FormatArg {
  return FormatArg { 
    tag: ARG_INT,
    str_ptr: "",
    int_val: arg,
    byte_val: '\0',
  };
}

pub const byte_arg -> fn (arg: byte) FormatArg {
  return FormatArg { 
    tag: ARG_BYTE,
    str_ptr: "",
    int_val: 0,
    byte_val: arg,
  };
}

#returns_ownership
const from_int -> fn (n: int) *byte {
  if (n == 0) { return "0"; }

  let negative: int = 0;
  if (n < 0) {
    negative = 1;
    n = -n;
  }

  let buffer: [byte; 20]; // enough for 64-bit int
  let i: int = 0;

  loop (n != 0) {
    let digit: int = n % 10;
    buffer[i] = cast<byte>(digit + cast<int>('0'));
    n = n / 10;
    i = i + 1;
  }

  if (negative == 1) {
    buffer[i] = '-';
    i = i + 1;
  }

  // Reverse the string
  let s: *byte = cast<*byte>(alloc((i + 1) * sizeof<byte>));
  loop [j: int = 0](j < i) : (j = j + 1) {
    s[j] = buffer[i - j - 1];
  }
  s[i] = cast<byte>(0); // null terminator

  return s;
}

/// Prints a formatted string with mixed-type arguments to stdout
///
/// This function performs printf-style formatting, supporting:
/// * %d - integers
/// * %s - strings
/// * %c - bytes/characters
/// * %f - floats (requires precision, e.g., %.2f)
///
/// The number of arguments consumed is determined by the number of format
/// specifiers in the format string. The args array is bounds-checked to
/// prevent buffer overruns.
///
/// # Parameters
/// * `s` - Format string containing text and format placeholders
/// * `args` - Array of FormatArg structs containing typed arguments
///
/// # Returns
/// The number of bytes written to stdout, or an error code if writing fails
///
/// # Example
/// ```luma
/// let args: [FormatArg; 256];
/// args[0] = str_arg("Alice");
/// args[1] = int_arg(30);
/// args[2] = byte_arg('A');
/// print("Name: %s, Age: %d, Initial: %c\n", args);
/// ```
///
/// # Memory
/// Allocates a 1024-byte temporary buffer which is automatically freed via defer
pub const print -> fn (s: *byte, args: [FormatArg; 256]) int {
    let buffer: *byte = cast<*byte>(alloc(1024 * sizeof<byte>));
    let buf_index: int = 0;
    let arg_index: int = 0;
    defer { free(buffer); }
    
    let i: int = 0;
    loop (s[i] != '\0') {
      if (s[i] == '%' && arg_index < 256) {
        let next: byte = s[i + 1];
        let arg: FormatArg = args[arg_index];
        
        switch (next) {
          'd' -> {
            if (arg.tag == ARG_INT) {
              let num_str: *byte = from_int(arg.int_val);
              defer { free(num_str); }
              
              loop [j: int = 0](num_str[j] != '\0') : (++j) {
                  buffer[buf_index] = num_str[j];
                  buf_index = buf_index + 1;
              }
              arg_index = arg_index + 1;
              i = i + 2; // Skip the 'd'
              continue;
            }
          }
          'c' -> {
            if (arg.tag == ARG_BYTE) {
              buffer[buf_index] = arg.byte_val;
              buf_index = buf_index + 1;
              arg_index = arg_index + 1;
              i = i + 2; // Skip the 'c'
              continue;
            }
          }
          's' -> {
            if (arg.tag == ARG_STR) {
                let str_arg: *byte = arg.str_ptr;
                
                loop [j: int = 0](str_arg[j] != '\0') : (++j) {
                    buffer[buf_index] = str_arg[j];
                    buf_index = buf_index + 1;
                }
                arg_index = arg_index + 1;
                i = i + 1; // Skip the 's'
                continue;
            }
          }
        }
      }

      buffer[buf_index] = s[i];
      buf_index = buf_index + 1;
      i = i + 1;
    }
    buffer[buf_index] = '\0';
    
    let written: int = local_write_str(STDOUT, buffer);
    return written;
}

/// Prints a formatted error message with integer arguments to stderr
///
/// This function is similar to print_int but writes to stderr instead of stdout.
/// It supports only the %d format specifier for integers and is intended for
/// error reporting.
///
/// # Parameters
/// * `s` - Format string containing text and %d placeholders
/// * `args` - Array of up to 256 integers to substitute into the format string
///
/// # Returns
/// The number of bytes written to stderr, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_err -> fn (s: *byte, args: [int; 256]) int {
  let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
  let buf_index: int = 0; 
  let arg_index: int = 0;
  defer { free(buffer); }
  
  loop [i: int = 0](s[i] != '\0') : (++i) {
      if (s[i] == '%' && s[i + 1] == 'd' && arg_index < 256) {
          let num_str: *byte = from_int(args[arg_index]);
          defer { free(num_str); }

          loop [j: int = 0](num_str[j] != '\0') : (++j) {
              buffer[buf_index] = num_str[j];
              buf_index = buf_index + 1;
          }
          arg_index = arg_index + 1;
          i = i + 1; // Skip 'd'
      } else {
          buffer[buf_index] = s[i];
          buf_index = buf_index + 1;
      }
  }
  buffer[buf_index] = '\0';

  let written: int = local_write_str(STDERR, buffer);
  return written;
}

/// Reads the entire contents of a file into a dynamically allocated buffer
///
/// This function opens a file, reads its complete contents into memory using a
/// dynamic buffer that grows as needed, and returns a pointer to the null-terminated
/// string. The buffer starts at INITIAL_BUFFER_SIZE (4KB) and doubles in size when
/// full until the entire file is read. After reading, the buffer is shrunk to the
/// exact size needed to minimize memory usage.
///
/// # Parameters
/// * `path` - Null-terminated string containing the file path to read
///
/// # Returns
/// A pointer to a newly allocated null-terminated string containing the file contents,
/// or a null pointer (0) if an error occurs. The caller is responsible for freeing
/// this memory.
///
/// # Memory
/// The returned buffer is heap-allocated and ownership is transferred to the caller.
/// The caller MUST free the returned pointer when done. Returns null on allocation
/// failures or read errors.
///
/// # Errors
/// Returns null pointer and prints error message to stderr if:
/// * File cannot be opened
/// * Memory allocation fails
/// * Read operation fails
#returns_ownership
pub const read_file -> fn (path: *byte) *byte {
  let fd: int = local_open(path, O_RDONLY, 0);
  if (local_is_error(fd)) {
    local_eprint("Error: File does not exist, can not read from file\n");
    return cast<*byte>(0);
  }

  // Start with initial buffer
  let buffer_size: int = INITIAL_BUFFER_SIZE;
  let buffer: *byte = cast<*byte>(alloc(buffer_size * sizeof<byte>));
  if (buffer == cast<*byte>(0)) {
    local_eprint("Error: Failed to allocate initial buffer\n");
    local_close(fd);
    return cast<*byte>(0);
  }

  let total_read: int = 0;
  let bytes_read: int = 0;

  loop {
    // Read into buffer at current position
    let read_size: int = buffer_size - total_read - 1; // Leave room for null terminator
    bytes_read = local_read(fd, cast<*void>(cast<int>(buffer) + total_read), read_size);

    if (local_is_error(bytes_read)) {
      local_eprint("Error: Failed to read from file\n");
      local_close(fd);
      free(buffer);
      return cast<*byte>(0);
    }

    // If we read 0 bytes, we've reached EOF
    if (bytes_read == 0) {
      break;
    }

    total_read = total_read + bytes_read;

    // If buffer is full (minus null terminator space), grow it
    if (total_read >= buffer_size - 1) {
      let new_size: int = buffer_size * BUFFER_GROWTH_FACTOR;
      let new_buffer: *byte = cast<*byte>(local_realloc(cast<*void>(buffer), new_size * sizeof<byte>));
      
      if (new_buffer == cast<*byte>(0)) {
        local_eprint("Error: Failed to grow buffer\n");
        local_close(fd);
        free(buffer);
        return cast<*byte>(0);
      }

      buffer = new_buffer;
      buffer_size = new_size;
    }
  }

  // Null terminate the string
  buffer[total_read] = cast<byte>(0);

  // Shrink buffer to exact size to save memory
  if (total_read < buffer_size - 1) {
    let final_buffer: *byte = cast<*byte>(alloc((total_read + 1) * sizeof<byte>));
    if (final_buffer != cast<*byte>(0)) {
      local_memcpy(cast<*void>(final_buffer), cast<*void>(buffer), total_read + 1);
      free(buffer);
      buffer = final_buffer;
    }
  }

  local_close(fd);
  return buffer;
}

/// Writes a buffer to a file
///
/// Opens an existing file and writes the entire buffer contents to it.
///
/// # Parameters
/// * `path` - Path to the file to write to
/// * `buffer` - Null-terminated string to write
///
/// # Returns
/// Number of bytes written, or -1 on error
pub const write_buffer_to_file -> fn (path: *byte, buffer: *byte) int {
    // Check file exists and open file
    let fd: int = local_open(path, O_RDWR, 0);
    if (local_is_error(fd)) {
       local_eprint("Error: File does not exist, can not write to file.\n");
       return -1;
    }
    
    // Calculate buffer length
    let length: int = 0;
    loop (buffer[length] != '\0') {
       length = length + 1;
    }

    if (length <= 0) {
       local_eprint("Error: buffer size <= 0.\n");
       local_close(fd);
       return -1;
    }
    
    // Write in one syscall
    let written: int = local_write(fd, cast<*void>(buffer), length);
    local_close(fd);

    return written;
}

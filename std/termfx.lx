@module "termfx"

@use "string" as string

pub const RESET: *byte   = "\x1b[0m";
pub const BLACK: *byte   = "\x1b[30m";
pub const RED: *byte     = "\x1b[31m";
pub const GREEN: *byte   = "\x1b[32m";
pub const YELLOW: *byte  = "\x1b[33m";
pub const BLUE: *byte    = "\x1b[34m";
pub const MAGENTA: *byte = "\x1b[35m";
pub const CYAN: *byte    = "\x1b[36m";
pub const WHITE: *byte   = "\x1b[37m";

pub const BRIGHT_BLACK: *byte   = "\x1b[1;90m";
pub const BRIGHT_RED: *byte     = "\x1b[1;91m";
pub const BRIGHT_GREEN: *byte   = "\x1b[1;92m";
pub const BRIGHT_YELLOW: *byte  = "\x1b[1;93m";
pub const BRIGHT_BLUE: *byte    = "\x1b[1;94m";
pub const BRIGHT_MAGENTA: *byte = "\x1b[1;95m";
pub const BRIGHT_CYAN: *byte    = "\x1b[1;96m";
pub const BRIGHT_WHITE: *byte   = "\x1b[1;97m";

pub const BG_BLACK: *byte   = "\x1b[40m";
pub const BG_RED: *byte     = "\x1b[41m";
pub const BG_GREEN: *byte   = "\x1b[42m";
pub const BG_YELLOW: *byte  = "\x1b[43m";
pub const BG_BLUE: *byte    = "\x1b[44m";
pub const BG_MAGENTA: *byte = "\x1b[45m";
pub const BG_CYAN: *byte    = "\x1b[46m";
pub const BG_WHITE: *byte   = "\x1b[47m";

pub const BG_BRIGHT_BLACK: *byte   = "\x1b[100m";
pub const BG_BRIGHT_RED: *byte     = "\x1b[101m";
pub const BG_BRIGHT_GREEN: *byte   = "\x1b[102m";
pub const BG_BRIGHT_YELLOW: *byte  = "\x1b[103m";
pub const BG_BRIGHT_BLUE: *byte    = "\x1b[104m";
pub const BG_BRIGHT_MAGENTA: *byte = "\x1b[105m";
pub const BG_BRIGHT_CYAN: *byte    = "\x1b[106m";
pub const BG_BRIGHT_WHITE: *byte   = "\x1b[107m";

pub const BOLD: *byte          = "\x1b[1m";
pub const DIM: *byte           = "\x1b[2m";
pub const ITALIC: *byte        = "\x1b[3m";  // not always supported
pub const UNDERLINE: *byte     = "\x1b[4m";
pub const BLINK: *byte         = "\x1b[5m";  // rarely supported
pub const INVERT: *byte        = "\x1b[7m";  // swap fg/bg
pub const HIDDEN: *byte        = "\x1b[8m";  // invisible text
pub const STRIKETHROUGH: *byte = "\x1b[9m";

pub const CLEAR_SCREEN: *byte  = "\x1b[2J";
pub const CLEAR_LINE: *byte    = "\x1b[2K";
pub const CURSOR_HOME: *byte   = "\x1b[H";
pub const CURSOR_HIDE: *byte   = "\x1b[?25l";
pub const CURSOR_SHOW: *byte   = "\x1b[?25h";

pub const SAVE_CURSOR: *byte    = "\x1b[s";
pub const RESTORE_CURSOR: *byte = "\x1b[u";

pub const CLEAR_TO_EOL: *byte = "\x1b[K";
pub const CLEAR_TO_EOS: *byte = "\x1b[J";

#returns_ownership
pub const fg_rgb -> fn (r: int, g: int, b: int) *byte {
    let msg: *byte = cast<*byte>(alloc(20 * sizeof<byte>));
    
    string::cat(msg, msg, "\x1b[38;2;");
    string::cat(msg, msg, string::from_int(r));
    string::cat(msg, msg, ";");
    string::cat(msg, msg, string::from_int(g));
    string::cat(msg, msg, ";");
    string::cat(msg, msg, string::from_int(b));
    string::cat(msg, msg, "m");

    return msg; 
}

#returns_ownership
pub const bg_rgb -> fn (r: int, g: int, b: int) *byte {
    let msg: *byte = cast<*byte>(alloc(20 * sizeof<byte>));

    string::cat(msg, msg, "\x1b[48;2;");
    string::cat(msg, msg, string::from_int(r));
    string::cat(msg, msg, ";");
    string::cat(msg, msg, string::from_int(g));
    string::cat(msg, msg, ";");
    string::cat(msg, msg, string::from_int(b));
    string::cat(msg, msg, "m");

    return msg;
}

#returns_ownership
pub const move_cursor -> fn (row: int, col: int) *byte {
    let msg: *byte = cast<*byte>(alloc(20 * sizeof<byte>));

    string::cat(msg, msg, "\x1b[");
    string::cat(msg, msg, string::from_int(row));
    string::cat(msg, msg, ";");
    string::cat(msg, msg, string::from_int(col));
    string::cat(msg, msg, "H");

    return msg;
}

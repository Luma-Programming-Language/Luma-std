//! Memory manipulation and allocation utilities
//!
//! This module provides low-level memory operations for copying, comparing,
//! and manipulating raw memory. It includes implementations of standard C
//! library memory functions, plus additional utilities for common operations.
//!
//! # Safety
//! These are low-level operations that work with raw pointers. Ensure that:
//! - Source and destination regions don't overlap (except for memmove)
//! - Pointers are valid and properly aligned
//! - Size parameters don't exceed allocated memory bounds

@module "std/memory"

/// Copies n bytes from src to dest
///
/// This is a byte-by-byte copy that does NOT handle overlapping regions.
/// Use memmove() for overlapping memory regions.
///
/// # Parameters
/// * `dest` - Destination memory address
/// * `src` - Source memory address  
/// * `n` - Number of bytes to copy
///
/// # Returns
/// The destination pointer
///
/// # Example
/// ```luma
/// let src: [int; 3] = [1, 2, 3];
/// let dest: [int; 3];
/// memory::memcpy(cast<*void>(&dest), cast<*void>(&src), 3 * sizeof<int>);
/// ```
pub const memcpy -> fn (dest: *void, src: *void, n: int) *void {
    let d: *byte = cast<*byte>(dest);
    let s: *byte = cast<*byte>(src);

    loop [i: int = 0](i < n) : (++i) {
        d[i] = s[i];
    }

    return dest;
}

/// Compares two memory regions byte by byte
///
/// Performs lexicographic comparison of memory contents.
///
/// # Parameters
/// * `a` - First memory region
/// * `b` - Second memory region
/// * `n` - Number of bytes to compare
///
/// # Returns
/// * `0` if regions are equal
/// * Positive value if first differing byte in a is greater
/// * Negative value if first differing byte in a is less
///
/// # Example
/// ```luma
/// let a: [int; 3] = [1, 2, 3];
/// let b: [int; 3] = [1, 2, 3];
/// if (memory::memcmp(cast<*void>(&a), cast<*void>(&b), 3 * sizeof<int>) == 0) {
///     output("Arrays are equal\n");
/// }
/// ```
pub const memcmp -> fn (a: *void, b: *void, n: int) int {
    let x: *byte = cast<*byte>(a);
    let y: *byte = cast<*byte>(b);
    loop [i: int = 0](i < n) : (++i) {
        if (x[i] != y[i]) {
            return cast<int>(x[i]) - cast<int>(y[i]);
        }
    }
    return 0;
}

/// Sets n bytes of memory to a specific value
///
/// Optimized implementation that processes 4 bytes at a time when possible,
/// then handles remaining bytes individually.
///
/// # Parameters
/// * `dest` - Memory address to fill
/// * `value` - Byte value to set (only low 8 bits used)
/// * `n` - Number of bytes to set
///
/// # Returns
/// The destination pointer
///
/// # Example
/// ```luma
/// let buffer: [byte; 100];
/// memory::memset(cast<*void>(&buffer), 0, 100); // Zero the buffer
/// ```
pub const memset -> fn (dest: *void, value: int, n: int) *void {
    let d: *byte = cast<*byte>(dest);
    let c:  byte = cast<byte>(value);
    let i:   int = 0;

    loop (i + 4 <= n) : (i = i + 4) {
        d[i] = c;
        d[i+1] = c;
        d[i+2] = c;
        d[i+3] = c;
    }

    loop (i < n) : (++i) { d[i] = c; }

    return dest;
}

/// Copies memory regions handling overlaps correctly
///
/// Unlike memcpy, this function correctly handles overlapping memory regions
/// by choosing the appropriate copy direction (forward or backward).
///
/// # Parameters
/// * `dest` - Destination memory address
/// * `src` - Source memory address
/// * `n` - Number of bytes to copy
///
/// # Returns
/// The destination pointer
///
/// # Example
/// ```luma
/// let buffer: [byte; 10];
/// // ... fill buffer ...
/// // Shift contents 2 bytes to the right (overlapping)
/// memory::memmove(cast<*void>(&buffer[2]), cast<*void>(&buffer[0]), 8);
/// ```
pub const memmove -> fn (dest: *void, src: *void, n: int) *void {
    let d: *byte = cast<*byte>(dest);
    let s: *byte = cast<*byte>(src);
    
    if (d < s) {
        // Copy forward
        loop [i: int = 0](i < n) : (++i) {
            d[i] = s[i];
        }
    } else {
        // Copy backward to handle overlap
        loop [i: int = n - 1](i >= 0) : (--i) {
            d[i] = s[i];
        }
    }
    
    return dest;
}

/// Finds first occurrence of a byte in memory
///
/// Scans memory for the first occurrence of a specific byte value.
///
/// # Parameters
/// * `ptr` - Memory region to search
/// * `value` - Byte value to find
/// * `n` - Number of bytes to search
///
/// # Returns
/// Pointer to first occurrence, or NULL (0) if not found
///
/// # Example
/// ```luma
/// let data: *byte = "Hello World";
/// let found: *byte = cast<*byte>(memory::memchr(cast<*void>(data), cast<int>('W'), 11));
/// if (found != cast<*byte>(0)) {
///     output("Found 'W'\n");
/// }
/// ```
pub const memchr -> fn (ptr: *void, value: int, n: int) *void {
    let p: *byte = cast<*byte>(ptr);
    let target: byte = cast<byte>(value);
    
    loop [i: int = 0](i < n) : (++i) {
        if (p[i] == target) {
            return cast<*void>(cast<int>(p) + i);
        }
    }
    
    return cast<*void>(0); // NULL
}

/// Zeroes out memory region
///
/// Convenience function equivalent to memset(dest, 0, n).
/// Useful for clearing sensitive data or initializing structures.
///
/// # Parameters
/// * `dest` - Memory address to zero
/// * `n` - Number of bytes to zero
///
/// # Returns
/// The destination pointer
///
/// # Example
/// ```luma
/// let password: [byte; 64];
/// // ... use password ...
/// memory::memzero(cast<*void>(&password), 64); // Clear sensitive data
/// ```
pub const memzero -> fn (dest: *void, n: int) *void { 
    return memset(dest, 0, n); 
}

/// Allocates and zeroes memory
///
/// Equivalent to C's calloc() - allocates memory for an array of elements
/// and initializes all bytes to zero.
///
/// # Parameters
/// * `count` - Number of elements
/// * `size` - Size of each element in bytes
///
/// # Returns
/// Pointer to allocated zeroed memory, or NULL on failure
///
/// # Example
/// ```luma
/// let array: *int = cast<*int>(memory::calloc(100, sizeof<int>));
/// defer { free(array); }
/// // All 100 integers are initialized to 0
/// ```
#returns_ownership
pub const calloc -> fn (count: int, size: int) *void {
    let total_size: int = count * size;
    let ptr: *void = alloc(total_size);
 
    if (ptr != cast<*void>(0)) {
        memzero(ptr, total_size);
    }
 
    return ptr;
}

/// Reallocates memory to a new size
///
/// Allocates a new block, copies old data, and frees the old block.
/// If ptr is NULL, behaves like alloc(). The old pointer becomes invalid.
///
/// # Parameters
/// * `ptr` - Pointer to existing allocation (or NULL)
/// * `new_size` - New size in bytes
///
/// # Returns
/// Pointer to new allocation, or NULL on failure
///
/// # Example
/// ```luma
/// let data: *int = cast<*int>(alloc(10 * sizeof<int>));
/// // ... need more space ...
/// data = cast<*int>(memory::realloc(cast<*void>(data), 20 * sizeof<int>));
/// ```
#returns_ownership 
pub const realloc -> fn (ptr: *void, new_size: int) *void {
    if (ptr == cast<*void>(0)) {
        return alloc(new_size);
    }
 
    let new_ptr: *void = alloc(new_size);
    memcpy(new_ptr, ptr, new_size);
    free(ptr);
 
    return new_ptr;
}

/// Swaps contents of two memory regions
///
/// Exchanges the bytes between two memory regions using a temporary variable.
/// The regions must be the same size.
///
/// # Parameters
/// * `a` - First memory region
/// * `b` - Second memory region
/// * `n` - Number of bytes to swap
///
/// # Example
/// ```luma
/// let x: int = 10;
/// let y: int = 20;
/// memory::memswap(cast<*void>(&x), cast<*void>(&y), sizeof<int>);
/// // Now x=20, y=10
/// ```
pub const memswap -> fn (a: *void, b: *void, n: int) void {
    let p1: *byte = cast<*byte>(a);
    let p2: *byte = cast<*byte>(b);
    
    loop [i: int = 0](i < n) : (++i) {
        let temp: byte = p1[i];
        p1[i] = p2[i];
        p2[i] = temp;
    }
}

/// Swaps multiple fixed-size elements between two arrays
///
/// Efficiently swaps count elements of size bytes between two arrays.
///
/// # Parameters
/// * `a` - First array
/// * `b` - Second array
/// * `count` - Number of elements to swap
/// * `size` - Size of each element in bytes
///
/// # Example
/// ```luma
/// let arr1: [int; 5] = [1, 2, 3, 4, 5];
/// let arr2: [int; 5] = [6, 7, 8, 9, 10];
/// memory::memswapn(cast<*void>(&arr1), cast<*void>(&arr2), 5, sizeof<int>);
/// ```
pub const memswapn -> fn (a: *void, b: *void, count: int, size: int) void {
    let temp: *void = alloc(size);

    loop [i: int = 0](i < count) : (++i) {
        let p1: *void = cast<*void>(cast<int>(a) + i * size);
        let p2: *void = cast<*void>(cast<int>(b) + i * size);
        
        memcpy(temp, p1, size);
        memcpy(p1, p2, size);
        memcpy(p2, temp, size);
    }

    free(temp);
}

/// Fills memory with repeated values
///
/// Optimized for common sizes (1 byte, 8 bytes). For other sizes,
/// fills with the low byte of value.
///
/// # Parameters
/// * `dest` - Destination memory
/// * `value` - Value to fill with
/// * `size` - Size of each element in bytes
/// * `count` - Number of elements to fill
///
/// # Returns
/// The destination pointer
///
/// # Example
/// ```luma
/// let array: [int; 100];
/// memory::memfill(cast<*void>(&array), 42, sizeof<int>, 100);
/// // All 100 elements are now 42
/// ```
pub const memfill -> fn (dest: *void, value: int, size: int, count: int) *void {
    if (size == 1) {
        // Fill byte/byte
        let d: *byte = cast<*byte>(dest);
        let byte_val: byte = cast<byte>(value);
        loop [i: int = 0](i < count) : (++i) {
            d[i] = byte_val;
        }
    } elif (size == 8) {
        // Fill int (8 bytes)
        let d: *int = cast<*int>(dest);
        loop [i: int = 0](i < count) : (++i) {
            d[i] = value;
        }
    } else {
        // For other sizes, just treat as bytes and fill with low byte of value
        let d: *byte = cast<*byte>(dest);
        let byte_val: byte = cast<byte>(value);
        let total: int = count * size;
        loop [i: int = 0](i < total) : (++i) {
            d[i] = byte_val;
        }
    }
    
    return dest;
}

/// Reverses bytes in memory region
///
/// Reverses the order of bytes in place.
///
/// # Parameters
/// * `ptr` - Memory region to reverse
/// * `n` - Number of bytes
///
/// # Returns
/// The pointer
///
/// # Example
/// ```luma
/// let data: [byte; 5] = ['H', 'e', 'l', 'l', 'o'];
/// memory::memrev(cast<*void>(&data), 5);
/// // Now: ['o', 'l', 'l', 'e', 'H']
/// ```
pub const memrev -> fn (ptr: *void, n: int) *void {
    let p: *byte = cast<*byte>(ptr);
    let start: int = 0;
    let end: int = n - 1;
    
    loop (start < end) : (++start) {
        let temp: byte = p[start];
        p[start] = p[end];
        p[end] = temp;
        --end;
    }
    
    return ptr;
}

/// Counts occurrences of a byte in memory
///
/// Scans memory and counts how many times a specific byte value appears.
///
/// # Parameters
/// * `ptr` - Memory region to search
/// * `value` - Byte value to count
/// * `n` - Number of bytes to search
///
/// # Returns
/// Number of occurrences found
///
/// # Example
/// ```luma
/// let text: *byte = "Hello World";
/// let count: int = memory::memcount(cast<*void>(text), cast<int>('l'), 11);
/// // count will be 3
/// ```
pub const memcount -> fn (ptr: *void, value: int, n: int) int {
    let p: *byte = cast<*byte>(ptr);
    let target: byte = cast<byte>(value);
    let count: int = 0;
    
    loop [i: int = 0](i < n) : (++i) {
        if (p[i] == target) {
            ++count;
        }
    }
    
    return count;
}

/// Duplicates a memory region
///
/// Allocates new memory and copies the source data. The caller is
/// responsible for freeing the returned pointer.
///
/// # Parameters
/// * `src` - Source memory to duplicate
/// * `n` - Number of bytes to duplicate
///
/// # Returns
/// Pointer to new allocation containing copy, or NULL on failure
///
/// # Example
/// ```luma
/// let original: [int; 5] = [1, 2, 3, 4, 5];
/// let copy: *int = cast<*int>(memory::memdup(cast<*void>(&original), 5 * sizeof<int>));
/// defer { free(copy); }
/// ```
#returns_ownership
pub const memdup -> fn (src: *void, n: int) *void {
    let dest: *void = alloc(n);
    if (dest != cast<*void>(0)) {
        memcpy(dest, src, n);
    }
    return dest;
}

/// Checks if two memory regions are equal
///
/// Convenience wrapper around memcmp that returns a boolean.
///
/// # Parameters
/// * `a` - First memory region
/// * `b` - Second memory region
/// * `n` - Number of bytes to compare
///
/// # Returns
/// true if regions are identical, false otherwise
///
/// # Example
/// ```luma
/// let a: [int; 3] = [1, 2, 3];
/// let b: [int; 3] = [1, 2, 3];
/// if (memory::memeq(cast<*void>(&a), cast<*void>(&b), 3 * sizeof<int>)) {
///     output("Equal!\n");
/// }
/// ```
pub const memeq -> fn (a: *void, b: *void, n: int) bool {
    return memcmp(a, b, n) == 0;
}

/// Finds a substring in memory
///
/// Searches for the first occurrence of a byte sequence (needle)
/// within a larger memory region (haystack).
///
/// # Parameters
/// * `haystack` - Memory to search in
/// * `haystack_len` - Length of haystack in bytes
/// * `needle` - Pattern to search for
/// * `needle_len` - Length of needle in bytes
///
/// # Returns
/// Pointer to first occurrence, or NULL if not found
///
/// # Example
/// ```luma
/// let text: *byte = "Hello World";
/// let pattern: *byte = "World";
/// let found: *void = memory::memmem(
///     cast<*void>(text), 11,
///     cast<*void>(pattern), 5
/// );
/// ```
pub const memmem -> fn (haystack: *void, haystack_len: int, needle: *void, needle_len: int) *void {
    if (needle_len == 0) { return haystack; }
    if (needle_len > haystack_len) { return cast<*void>(0); }
    
    let h: *byte = cast<*byte>(haystack);
    let n: *byte = cast<*byte>(needle);
    let limit: int = haystack_len - needle_len;
    
    loop [i: int = 0](i <= limit) : (++i) {
        let found: int = 1;
        loop [j: int = 0](j < needle_len) : (++j) {
            if (h[i + j] != n[j]) {
                found = 0;
                break;
            }
        }
        if (found == 1) {
            return cast<*void>(cast<int>(h) + i);
        }
    }
    
    return cast<*void>(0);
}

/// Calculates alignment for struct members
///
/// Returns the maximum alignment requirement from a list of member alignments.
/// Used for determining struct alignment.
///
/// # Parameters
/// * `member_alignments` - Array of alignment values
/// * `count` - Number of alignments in array
///
/// # Returns
/// Maximum alignment value
///
/// # Example
/// ```luma
/// let alignments: [int; 3] = [4, 8, 4];
/// let struct_align: int = memory::align(&alignments[0], 3);
/// // Returns 8 (largest alignment)
/// ```
pub const align -> fn (member_alignments: *int, count: int) int {
    let max: int = 1;
    loop [i: int = 0](i < count) : (++i) {
        if (max < cast<*int>(member_alignments)[i]) {
            max = cast<*int>(member_alignments)[i];
        }
    }
    return max;
}
